import{c as X,t as o,a as x,ah as T,bt as y,bu as M}from"./index-CIyudF9t.js";import{e as O,d as b}from"./subDays-gmpfwhzv.js";import{g as N,e as _,a as I}from"./en-US-PHonLEz-.js";/**
 * @license lucide-react v0.539.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const w=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],j=X("circle-check",w);function D(n,r){const e=o(n),c=o(r),t=e.getTime()-c.getTime();return t<0?-1:t>0?1:t}function R(n){return x(n,Date.now())}function k(n){return r=>{const c=(n?Math[n]:Math.trunc)(r);return c===0?0:c}}function C(n,r){return+o(n)-+o(r)}function L(n){const r=o(n);return+T(r)==+O(r)}function Y(n,r){const e=o(n),c=o(r),t=D(e,c),u=Math.abs(b(e,c));let f;if(u<1)f=0;else{e.getMonth()===1&&e.getDate()>27&&e.setDate(30),e.setMonth(e.getMonth()-t*u);let s=D(e,c)===-t;L(o(n))&&u===1&&D(n,c)===1&&(s=!1),f=t*(u-Number(s))}return f===0?0:f}function v(n,r,e){const c=C(n,r)/1e3;return k(e==null?void 0:e.roundingMethod)(c)}function z(n,r,e){const c=N(),t=(e==null?void 0:e.locale)??c.locale??_,u=2520,f=D(n,r);if(isNaN(f))throw new RangeError("Invalid time value");const s=Object.assign({},e,{addSuffix:e==null?void 0:e.addSuffix,comparison:f});let d,h;f>0?(d=o(r),h=o(n)):(d=o(n),h=o(r));const l=v(h,d),S=(I(h)-I(d))/1e3,a=Math.round((l-S)/60);let m;if(a<2)return e!=null&&e.includeSeconds?l<5?t.formatDistance("lessThanXSeconds",5,s):l<10?t.formatDistance("lessThanXSeconds",10,s):l<20?t.formatDistance("lessThanXSeconds",20,s):l<40?t.formatDistance("halfAMinute",0,s):l<60?t.formatDistance("lessThanXMinutes",1,s):t.formatDistance("xMinutes",1,s):a===0?t.formatDistance("lessThanXMinutes",1,s):t.formatDistance("xMinutes",a,s);if(a<45)return t.formatDistance("xMinutes",a,s);if(a<90)return t.formatDistance("aboutXHours",1,s);if(a<y){const i=Math.round(a/60);return t.formatDistance("aboutXHours",i,s)}else{if(a<u)return t.formatDistance("xDays",1,s);if(a<M){const i=Math.round(a/y);return t.formatDistance("xDays",i,s)}else if(a<M*2)return m=Math.round(a/M),t.formatDistance("aboutXMonths",m,s)}if(m=Y(h,d),m<12){const i=Math.round(a/M);return t.formatDistance("xMonths",i,s)}else{const i=m%12,g=Math.trunc(m/12);return i<3?t.formatDistance("aboutXYears",g,s):i<9?t.formatDistance("overXYears",g,s):t.formatDistance("almostXYears",g+1,s)}}function E(n,r){return z(n,R(n),r)}export{j as C,R as c,C as d,E as f,k as g};
